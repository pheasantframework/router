function h(a,e,r){const t=e.exec(a),s=r.split("/").map(n=>n.startsWith(":")?n.replace(":",""):null).filter(n=>n!==null);if(t&&t.length>1){const n={};for(let o=0;o<s.length&&o<t.length-1;o++)n[s[o]]=t[o+1];return n}else return null}function l(a){const r=`^${a.split("/").map(t=>t.startsWith(":")?"([^/]+)":t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")).join("/")}/?$`;return new RegExp(r)}function p(a,e,r){const t=new URL(a.location.href),s=t.searchParams,n={};s.forEach((u,c)=>{n[c]=u});const o=h(t.pathname,r,e);return{name:a.location.pathname,query:n,params:o??void 0,hash:t.hash}}class i{routes;constructor(){this.routes=[]}get(e,r){if(!e||!r)throw new Error("uri or callback must be given");if(typeof e!="string")throw new Error("typeof uri must be a string");if(typeof r!="function")throw new TypeError("typeof callback must be a function");this.routes.forEach(s=>{if(s.uri===e)throw new Error(`the uri ${s.uri} already exists`)});const t={uri:e,callback:r};this.routes.push(t)}init(){this.routes.some(e=>{const r=l(e.uri);if(window.location.pathname.match(r)){const s=p(window,e.uri,r);return e.callback.call(this,s)}})}}window.Router=i;export{i as Router};
