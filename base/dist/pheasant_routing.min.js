function c(a,e,r){const t=e.exec(a),s=r.split("/").map(n=>n.startsWith(":")?n.replace(":",""):null).filter(n=>n!==null);if(t&&t.length>1){const n={};for(let o=0;o<s.length&&o<t.length-1;o++)n[s[o]]=t[o+1];return n}else return null}function h(a){const r=`^${a.split("/").map(t=>t.startsWith(":")?"([^/]+)":t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")).join("/")}/?$`;return new RegExp(r)}function l(a,e,r){const t=new URL(a.location.href),s=t.searchParams,n={};s.forEach((i,u)=>{n[u]=i});const o=c(t.pathname,r,e);return{name:a.location.pathname,query:n,params:o??void 0,hash:t.hash}}class p{routes;constructor(){this.routes=[]}get(e,r){if(!e||!r)throw new Error("uri or callback must be given");if(typeof e!="string")throw new Error("typeof uri must be a string");if(typeof r!="function")throw new TypeError("typeof callback must be a function");this.routes.forEach(s=>{if(s.uri===e)throw new Error(`the uri ${s.uri} already exists`)});const t={uri:e,callback:r};this.routes.push(t)}init(){this.routes.some(e=>{const r=h(e.uri);if(window.location.pathname.match(r)){const s=l(window,e.uri,r);return e.callback.call(this,s)}})}}export{p as Router};
